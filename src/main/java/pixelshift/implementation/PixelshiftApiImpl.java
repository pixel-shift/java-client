/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package pixelshift.implementation;

import pixelshift.PixelshiftApi;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.UUID;
import okhttp3.ResponseBody;
import pixelshift.models.AllBatchesPageResponse;
import pixelshift.models.Batch;
import pixelshift.models.BatchReportResponse;
import pixelshift.models.BatchStartReportResponse;
import pixelshift.models.OperationStatusReportResponse;
import pixelshift.models.TransformGraphMetadataEnvelope;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.PUT;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the PixelshiftApi class.
 */
public class PixelshiftApiImpl extends ServiceClient implements PixelshiftApi {
    /**
     * The Retrofit service to perform REST calls.
     */
    private PixelshiftApiService service;

    /**
     * Initializes an instance of PixelshiftApi client.
     */
    public PixelshiftApiImpl() {
        this("https://");
    }

    /**
     * Initializes an instance of PixelshiftApi client.
     *
     * @param baseUrl the base URL of the host
     */
    public PixelshiftApiImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of PixelshiftApi client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public PixelshiftApiImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of PixelshiftApi client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public PixelshiftApiImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of PixelshiftApi client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public PixelshiftApiImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(PixelshiftApiService.class);
    }

    /**
     * The interface defining all the services for PixelshiftApi to be
     * used by Retrofit to perform actually REST calls.
     */
    interface PixelshiftApiService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: pixelshift.PixelshiftApi processImageBatch" })
        @PUT("api/v1/batch/images")
        Observable<Response<ResponseBody>> processImageBatch(@Body Batch batch);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: pixelshift.PixelshiftApi allBatches" })
        @GET("api/v1/list/all-batches")
        Observable<Response<ResponseBody>> allBatches();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: pixelshift.PixelshiftApi batchInfo" })
        @GET("api/v1/status/batch/{batchId}")
        Observable<Response<ResponseBody>> batchInfo(@Path("batchId") UUID batchId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: pixelshift.PixelshiftApi operationStatus" })
        @GET("api/v1/status/operation/{operationId}")
        Observable<Response<ResponseBody>> operationStatus(@Path("operationId") UUID operationId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: pixelshift.PixelshiftApi operationDescription" })
        @GET("api/v1/description/operation/{operationId}")
        Observable<Response<ResponseBody>> operationDescription(@Path("operationId") UUID operationId);

    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BatchStartReportResponse object if successful.
     */
    public BatchStartReportResponse processImageBatch() {
        return processImageBatchWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BatchStartReportResponse> processImageBatchAsync(final ServiceCallback<BatchStartReportResponse> serviceCallback) {
        return ServiceFuture.fromResponse(processImageBatchWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BatchStartReportResponse object
     */
    public Observable<BatchStartReportResponse> processImageBatchAsync() {
        return processImageBatchWithServiceResponseAsync().map(new Func1<ServiceResponse<BatchStartReportResponse>, BatchStartReportResponse>() {
            @Override
            public BatchStartReportResponse call(ServiceResponse<BatchStartReportResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BatchStartReportResponse object
     */
    public Observable<ServiceResponse<BatchStartReportResponse>> processImageBatchWithServiceResponseAsync() {
        final Batch batch = null;
        return service.processImageBatch(batch)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BatchStartReportResponse>>>() {
                @Override
                public Observable<ServiceResponse<BatchStartReportResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BatchStartReportResponse> clientResponse = processImageBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @param batch The batch to be processed
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BatchStartReportResponse object if successful.
     */
    public BatchStartReportResponse processImageBatch(Batch batch) {
        return processImageBatchWithServiceResponseAsync(batch).toBlocking().single().body();
    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @param batch The batch to be processed
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BatchStartReportResponse> processImageBatchAsync(Batch batch, final ServiceCallback<BatchStartReportResponse> serviceCallback) {
        return ServiceFuture.fromResponse(processImageBatchWithServiceResponseAsync(batch), serviceCallback);
    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @param batch The batch to be processed
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BatchStartReportResponse object
     */
    public Observable<BatchStartReportResponse> processImageBatchAsync(Batch batch) {
        return processImageBatchWithServiceResponseAsync(batch).map(new Func1<ServiceResponse<BatchStartReportResponse>, BatchStartReportResponse>() {
            @Override
            public BatchStartReportResponse call(ServiceResponse<BatchStartReportResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Endpoint for submitting batches for processing.
     *
     * @param batch The batch to be processed
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BatchStartReportResponse object
     */
    public Observable<ServiceResponse<BatchStartReportResponse>> processImageBatchWithServiceResponseAsync(Batch batch) {
        Validator.validate(batch);
        return service.processImageBatch(batch)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BatchStartReportResponse>>>() {
                @Override
                public Observable<ServiceResponse<BatchStartReportResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BatchStartReportResponse> clientResponse = processImageBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BatchStartReportResponse> processImageBatchDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<BatchStartReportResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BatchStartReportResponse>() { }.getType())
                .register(400, new TypeToken<BatchStartReportResponse>() { }.getType())
                .register(500, new TypeToken<BatchStartReportResponse>() { }.getType())
                .register(502, new TypeToken<BatchStartReportResponse>() { }.getType())
                .build(response);
    }

    /**
     * List all batches.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AllBatchesPageResponse object if successful.
     */
    public AllBatchesPageResponse allBatches() {
        return allBatchesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * List all batches.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AllBatchesPageResponse> allBatchesAsync(final ServiceCallback<AllBatchesPageResponse> serviceCallback) {
        return ServiceFuture.fromResponse(allBatchesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * List all batches.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AllBatchesPageResponse object
     */
    public Observable<AllBatchesPageResponse> allBatchesAsync() {
        return allBatchesWithServiceResponseAsync().map(new Func1<ServiceResponse<AllBatchesPageResponse>, AllBatchesPageResponse>() {
            @Override
            public AllBatchesPageResponse call(ServiceResponse<AllBatchesPageResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * List all batches.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AllBatchesPageResponse object
     */
    public Observable<ServiceResponse<AllBatchesPageResponse>> allBatchesWithServiceResponseAsync() {
        return service.allBatches()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AllBatchesPageResponse>>>() {
                @Override
                public Observable<ServiceResponse<AllBatchesPageResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AllBatchesPageResponse> clientResponse = allBatchesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AllBatchesPageResponse> allBatchesDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<AllBatchesPageResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<AllBatchesPageResponse>() { }.getType())
                .build(response);
    }

    /**
     * The processing status of a batch.
     *
     * @param batchId the id of the batch to query
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BatchReportResponse object if successful.
     */
    public BatchReportResponse batchInfo(UUID batchId) {
        return batchInfoWithServiceResponseAsync(batchId).toBlocking().single().body();
    }

    /**
     * The processing status of a batch.
     *
     * @param batchId the id of the batch to query
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BatchReportResponse> batchInfoAsync(UUID batchId, final ServiceCallback<BatchReportResponse> serviceCallback) {
        return ServiceFuture.fromResponse(batchInfoWithServiceResponseAsync(batchId), serviceCallback);
    }

    /**
     * The processing status of a batch.
     *
     * @param batchId the id of the batch to query
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BatchReportResponse object
     */
    public Observable<BatchReportResponse> batchInfoAsync(UUID batchId) {
        return batchInfoWithServiceResponseAsync(batchId).map(new Func1<ServiceResponse<BatchReportResponse>, BatchReportResponse>() {
            @Override
            public BatchReportResponse call(ServiceResponse<BatchReportResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * The processing status of a batch.
     *
     * @param batchId the id of the batch to query
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BatchReportResponse object
     */
    public Observable<ServiceResponse<BatchReportResponse>> batchInfoWithServiceResponseAsync(UUID batchId) {
        if (batchId == null) {
            throw new IllegalArgumentException("Parameter batchId is required and cannot be null.");
        }
        return service.batchInfo(batchId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BatchReportResponse>>>() {
                @Override
                public Observable<ServiceResponse<BatchReportResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BatchReportResponse> clientResponse = batchInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BatchReportResponse> batchInfoDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BatchReportResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BatchReportResponse>() { }.getType())
                .build(response);
    }

    /**
     * The processing status of a specific operation.
     *
     * @param operationId the id of the operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusReportResponse object if successful.
     */
    public OperationStatusReportResponse operationStatus(UUID operationId) {
        return operationStatusWithServiceResponseAsync(operationId).toBlocking().single().body();
    }

    /**
     * The processing status of a specific operation.
     *
     * @param operationId the id of the operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusReportResponse> operationStatusAsync(UUID operationId, final ServiceCallback<OperationStatusReportResponse> serviceCallback) {
        return ServiceFuture.fromResponse(operationStatusWithServiceResponseAsync(operationId), serviceCallback);
    }

    /**
     * The processing status of a specific operation.
     *
     * @param operationId the id of the operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusReportResponse object
     */
    public Observable<OperationStatusReportResponse> operationStatusAsync(UUID operationId) {
        return operationStatusWithServiceResponseAsync(operationId).map(new Func1<ServiceResponse<OperationStatusReportResponse>, OperationStatusReportResponse>() {
            @Override
            public OperationStatusReportResponse call(ServiceResponse<OperationStatusReportResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * The processing status of a specific operation.
     *
     * @param operationId the id of the operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusReportResponse object
     */
    public Observable<ServiceResponse<OperationStatusReportResponse>> operationStatusWithServiceResponseAsync(UUID operationId) {
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        return service.operationStatus(operationId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusReportResponse>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusReportResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusReportResponse> clientResponse = operationStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusReportResponse> operationStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<OperationStatusReportResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<OperationStatusReportResponse>() { }.getType())
                .build(response);
    }

    /**
     * A description of the original operation parameters.
     *
     * @param operationId the operation id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformGraphMetadataEnvelope object if successful.
     */
    public TransformGraphMetadataEnvelope operationDescription(UUID operationId) {
        return operationDescriptionWithServiceResponseAsync(operationId).toBlocking().single().body();
    }

    /**
     * A description of the original operation parameters.
     *
     * @param operationId the operation id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformGraphMetadataEnvelope> operationDescriptionAsync(UUID operationId, final ServiceCallback<TransformGraphMetadataEnvelope> serviceCallback) {
        return ServiceFuture.fromResponse(operationDescriptionWithServiceResponseAsync(operationId), serviceCallback);
    }

    /**
     * A description of the original operation parameters.
     *
     * @param operationId the operation id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformGraphMetadataEnvelope object
     */
    public Observable<TransformGraphMetadataEnvelope> operationDescriptionAsync(UUID operationId) {
        return operationDescriptionWithServiceResponseAsync(operationId).map(new Func1<ServiceResponse<TransformGraphMetadataEnvelope>, TransformGraphMetadataEnvelope>() {
            @Override
            public TransformGraphMetadataEnvelope call(ServiceResponse<TransformGraphMetadataEnvelope> response) {
                return response.body();
            }
        });
    }

    /**
     * A description of the original operation parameters.
     *
     * @param operationId the operation id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformGraphMetadataEnvelope object
     */
    public Observable<ServiceResponse<TransformGraphMetadataEnvelope>> operationDescriptionWithServiceResponseAsync(UUID operationId) {
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        return service.operationDescription(operationId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformGraphMetadataEnvelope>>>() {
                @Override
                public Observable<ServiceResponse<TransformGraphMetadataEnvelope>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformGraphMetadataEnvelope> clientResponse = operationDescriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformGraphMetadataEnvelope> operationDescriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformGraphMetadataEnvelope, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformGraphMetadataEnvelope>() { }.getType())
                .build(response);
    }

}
